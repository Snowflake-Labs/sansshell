syntax = "proto3";

option go_package = "github.com/Snowflake-Labs/sansshell/services/localfile";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

package LocalFile;

// The LocalFile service definition.
service LocalFile {
  // Read reads a file from the disk and returns it contents.
  rpc Read(ReadActionRequest) returns (stream ReadReply) {}

  // Stat returns metadata about a filesytem path.
  rpc Stat(stream StatRequest) returns (stream StatReply) {}

  // Sum calculates a sum over the data in a single file.
  rpc Sum(stream SumRequest) returns (stream SumReply) {}

  // Write writes a file from the incoming RPC to a local file.
  rpc Write(stream WriteRequest) returns (google.protobuf.Empty) {}

  // Copy retrieves a file from the given blob URL and writes it to a local
  // file.
  rpc Copy(CopyRequest) returns (google.protobuf.Empty) {}

  // List returns StatReply entries for the entities contained at a given path.
  rpc List(ListRequest) returns (stream ListReply) {}

  // SetFileAttributes takes a given filename and sets the given attributes.
  rpc SetFileAttributes(SetFileAttributesRequest)
      returns (google.protobuf.Empty) {}
}

// ReadActionRequest indicates the type of read we're performing.
// Either a file read which then terminates or a tail based read that
// continues forever (i.e. as tail -f on the command line would do).
message ReadActionRequest {
  oneof request {
    ReadRequest file = 1;
    TailRequest tail = 2;
  }
}

// ReadRequest describes the filename to be read
message ReadRequest {
  string filename = 1;
  // If non-zero skip N bytes into the file before returning data.
  // Negative implies based from end of file.
  int64 offset = 2;
  // If positive and non-zero return only this many total bytes.
  int64 length = 3;
}

// TailRequest describes the filename to be tailed.
message TailRequest {
  string filename = 1;
  // If non-zero skip N bytes into the file before returning data.
  // Negative implies based from end of file.
  int64 offset = 2;
}

// ReadResponse contains the contents of the file
message ReadReply { bytes contents = 1; }

// StatRequest specifies the filename for which to retrieve metadata.
message StatRequest {
  // absolute path to the target file
  string filename = 1;
}

// StatReply contains stat information for a single file.
message StatReply {
  // The file path, as provided in StatRequest
  string filename = 1;
  // size of the file, in bytes
  int64 size = 2;
  // NB: the file mode here is represented using Go's fs.FileMode scheme
  // which combines permissions with additional data such as the type
  // (directory, symlink, etc)
  uint32 mode = 3;
  // File modification time
  google.protobuf.Timestamp modtime = 4;
  // UID of owner
  uint32 uid = 5;
  // GID of owner
  uint32 gid = 6;
  // Whether the immutable flag is set.
  // This only applies to systems which support immutable file bits.
  bool immutable = 7;
}

// SumType specifies a hashing function to use when calculating
// file sums.
enum SumType {
  SUM_TYPE_UNKNOWN = 0;
  SUM_TYPE_CRC32IEEE = 1;
  SUM_TYPE_MD5 = 2;
  SUM_TYPE_SHA256 = 3;
  SUM_TYPE_SHA512_256 = 4;
}

// SumRequest specifies a type and filename for a sum operation.
message SumRequest {
  // Absoloute path to the target file.
  string filename = 1;
  // The requested sum type. If not set, or SUM_TYPE_UNKNOWN,
  // an implementation-default value will be chosen automatically,
  // and indicated in the reply.
  SumType sum_type = 2;
}

// SumReply contains the sum output for the given filename.
message SumReply {
  // Filename, as provided in SumRequest
  string filename = 1;
  // The type of sum used to calculate `sum`
  SumType sum_type = 2;
  // The sum value, as a hex-encoded string
  string sum = 3;
}

// FileAttributes describes a file by it's name and expected user/group and
// permissions.
message FileAttributes {
  // Must be a fully qualified and clean path name (i.e. absolute and no ../
  // style).
  string filename = 1;
  // Permissions for the written file in unix style (lower 12 bits only).
  uint32 permissions = 2;
  // If not blank the user to set as the owner of the file. If blank the
  // file must previously exist and overwrite above is set to true.
  string user = 3;
  // If not blank the group to set as the group of the file. If blank the
  // file must previously exist and overwrite above is set to true.
  string group = 4;
  // If true will set the immutable bit on the file. False will clear it.
  // This only applies to systems which support immutable file bits.
  bool immutable = 5;
}

// FileWrite describes everything about a file to be written.
message FileWrite {
  FileAttributes attrs = 1;
  // If true allow to truncate and overwrite an existing file. Otherwise
  // the file must not exist. This is still subject to races as all incoming
  // data is written to a tempfile before moved to the final destination so
  // multiple system calls will take place.
  bool overwrite = 2;
}

// WriteRequest streams the data for the filename to be written.
// The first request must contain a description and all future requests
// must contain contents. Each write request will append contents into the
// file until the stream is closed. Then the file is moved to it's final
// location.
message WriteRequest {
  oneof request {
    FileWrite description = 1;
    bytes contents = 2;
  }
}

// CopyRequest contains the URL and filename destination to copy the
// file from.
message CopyRequest {
  FileWrite destination = 1;
  // The source URL to copy from. See implementations for details on schemes
  // but will at a minimum support file://<path> for local copies.
  string source_url = 2;
  // Any additional data the URL destination may need in order
  // to succeed (such as an auth token for a blob service).
  bytes blob_data = 3;
}

message ListRequest {
  // The directory to list.
  string directory = 1;
  // Whether to recurse through the tree rooted at directory.
  bool recurse = 2;
}

// ListReply will begin with a directory followed by N entries
// until that level of the tree is exhausted. If recurse is set
// a new set of directory + entry replies will be sent. This will
// continue in breadth first form until the entire tree has been
// returned.
message ListReply {
  oneof reply {
    StatReply directory = 1;
    StatReply entry = 2;
  }
}

message SetFileAttributesRequest { FileAttributes attrs = 1; }