/* Copyright (c) 2024 Snowflake Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the
   "License"); you may not use this file except in compliance
   with the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing,
   software distributed under the License is distributed on an
   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied.  See the License for the
   specific language governing permissions and limitations
   under the License.
*/

package server

import (
	"context"
	"io"
	"log"
	"net"
	"os"
	"testing"

	"github.com/google/gopacket/pcap"
	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/timestamppb"

	pb "github.com/Snowflake-Labs/sansshell/services/network"
	"github.com/Snowflake-Labs/sansshell/testing/testutil"
)

var (
	bufSize = 1024 * 1024
	lis     *bufconn.Listener
	conn    *grpc.ClientConn
)

func bufDialer(context.Context, string) (net.Conn, error) {
	return lis.Dial()
}

func TestMain(m *testing.M) {
	lis = bufconn.Listen(bufSize)
	s := grpc.NewServer()
	lfs := &server{}
	lfs.Register(s)
	go func() {
		if err := s.Serve(lis); err != nil {
			log.Fatalf("Server exited with error: %v", err)
		}
	}()
	defer s.GracefulStop()

	os.Exit(m.Run())
}

func mockFetchInterfaces() ([]net.Interface, error) {
	return testInterfaces, nil
}

func mockGetPcapHandle(filepath string, _ int32) (*pcap.Handle, error) {
	// TODO: mock implementation does not support snaplen
	handle, err := pcap.OpenOffline(filepath)
	if err != nil {
		return nil, err
	}
	return handle, nil
}

func TestListInterfaces(t *testing.T) {
	s := &server{}

	// Use our own mock interface data for testing
	origFetchInterfaces := fetchInterfaces
	t.Cleanup(func() {
		fetchInterfaces = origFetchInterfaces
	})
	fetchInterfaces = mockFetchInterfaces

	got, err := s.ListInterfaces(context.Background(), &emptypb.Empty{})
	if err != nil {
		t.Fatal("unexpected error: ", err)
	}
	want := &pb.ListInterfacesReply{
		Interfaces: []*pb.Interface{
			{Index: 1, Name: "lo", Flags: uint32(net.FlagLoopback | net.FlagUp | net.FlagRunning)},
			{Index: 2, Name: "wlan0"},
			{Index: 3, Name: "testdata/sample.pcap", Flags: uint32(net.FlagUp | net.FlagRunning)},
		},
	}
	testutil.DiffErr(t.Name(), got, want, t)
}

func TestDefaultCaptureInterface(t *testing.T) {
	// Use our own mock interface data for testing
	origFetchInterfaces := fetchInterfaces
	t.Cleanup(func() {
		fetchInterfaces = origFetchInterfaces
	})
	fetchInterfaces = mockFetchInterfaces

	got := defaultCaptureInterface()
	want := testInterfaces[2].Name
	assert.Equal(t, want, got)
}

func TestRawStream(t *testing.T) {
	// Use our own mock interface data for testing
	origGetPcapHandle := getPcapHandle
	t.Cleanup(func() {
		getPcapHandle = origGetPcapHandle
	})
	getPcapHandle = mockGetPcapHandle
	origFetchInterfaces := fetchInterfaces
	t.Cleanup(func() {
		fetchInterfaces = origFetchInterfaces
	})
	fetchInterfaces = mockFetchInterfaces

	var err error
	conn, err = grpc.DialContext(context.Background(), "bufnet", grpc.WithContextDialer(bufDialer), grpc.WithTransportCredentials(insecure.NewCredentials()))
	assert.NoError(t, err, "failed to dial bufnet")
	t.Cleanup(func() { conn.Close() })

	client := pb.NewPacketCaptureClient(conn)

	for _, tc := range []struct {
		name  string
		req   *pb.RawStreamRequest
		reply []*pb.RawStreamReply
		err   string
	}{
		{
			name:  "no-filter",
			req:   &pb.RawStreamRequest{},
			reply: testdataPackets,
		},
		{
			name:  "invalid-filter",
			err:   "expression rejects all packets",
			req:   &pb.RawStreamRequest{Filter: "icmp and tcp and udp"},
			reply: []*pb.RawStreamReply{},
		},
		{
			name:  "permissive-filter",
			req:   &pb.RawStreamRequest{Filter: "icmp or tcp or udp"},
			reply: testdataPackets,
		},
		{
			name:  "dns",
			req:   &pb.RawStreamRequest{Filter: "port 53"},
			reply: []*pb.RawStreamReply{testdataPackets[2], testdataPackets[3]},
		},
		{
			name:  "http-reply",
			req:   &pb.RawStreamRequest{Filter: "(tcp and dst port 80) and greater 130"},
			reply: []*pb.RawStreamReply{testdataPackets[7]},
		},
	} {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			var gotRecords []*pb.RawStreamReply
			stream, err := client.RawStream(context.Background(), tc.req)
			testutil.FatalOnErr("unexpected client error", err, t)
			for {
				resp, err := stream.Recv()
				if err == io.EOF {
					break
				}
				if tc.err == "" {
					testutil.FatalOnErr("unexpected stream error", err, t)
				} else {
					assert.ErrorContains(t, err, tc.err)
					// If the error was expected, there is nothing else to do.
					return
				}
				gotRecords = append(gotRecords, resp)
			}
			testutil.DiffErr(tc.name, gotRecords, tc.reply, t)
		})
	}
}

// Test data

var testInterfaces = []net.Interface{
	{Index: 1, Name: "lo", Flags: net.FlagLoopback | net.FlagUp | net.FlagRunning},
	{Index: 2, Name: "wlan0"},
	{Index: 3, Name: "testdata/sample.pcap", Flags: net.FlagUp | net.FlagRunning},
}

// Comments below generated with `tshark -t e.9 -nr services/network/server/testdata/sample.pcap`
var testdataPackets = []*pb.RawStreamReply{
	{
		// 1 1706286340.440181000 172.20.132.30 → 1.1.1.1      ICMP 98 Echo (ping) request  id=0xf2e8, seq=0/0, ttl=64
		Data:      []byte{0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x8, 0x0, 0x45, 0x0, 0x0, 0x54, 0xc2, 0x36, 0x0, 0x0, 0x40, 0x1, 0x86, 0x3e, 0xac, 0x14, 0x84, 0x1e, 0x1, 0x1, 0x1, 0x1, 0x8, 0x0, 0x13, 0x8c, 0xf2, 0xe8, 0x0, 0x0, 0x65, 0xb3, 0xdd, 0x4, 0x0, 0x6, 0xb4, 0x9b, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68},
		Timestamp: &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 440181000},

		FullLength: 98,
	}, {
		// 2 1706286340.447421000      1.1.1.1 → 172.20.132.30 ICMP 98 Echo (ping) reply    id=0xf2e8, seq=0/0, ttl=60 (request in 1)
		Data:       []byte{0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x8, 0x0, 0x45, 0x0, 0x0, 0x54, 0x26, 0xf0, 0x0, 0x0, 0x3c, 0x1, 0x25, 0x85, 0x1, 0x1, 0x1, 0x1, 0xac, 0x14, 0x84, 0x1e, 0x0, 0x0, 0x1b, 0x8c, 0xf2, 0xe8, 0x0, 0x0, 0x65, 0xb3, 0xdd, 0x4, 0x0, 0x6, 0xb4, 0x9b, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68, 0x65, 0x72, 0x65, 0x21, 0x6c, 0x39, 0x69, 0x20, 0x77, 0x61, 0x73, 0x20, 0x68},
		FullLength: 98,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 447421000},
	}, {
		// 3 1706286340.464256000 172.20.132.30 → 8.8.8.8      DNS 73 Standard query 0x7ff5 A snowflake.com
		Data:       []byte{0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x8, 0x0, 0x45, 0x0, 0x0, 0x3b, 0x7e, 0x73, 0x0, 0x0, 0x40, 0x11, 0xbb, 0xfc, 0xac, 0x14, 0x84, 0x1e, 0x8, 0x8, 0x8, 0x8, 0xc5, 0xcc, 0x0, 0x35, 0x0, 0x27, 0x3c, 0x85, 0x7f, 0xf5, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1},
		FullLength: 73,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 464256000},
	}, {
		// 4 1706286340.491180000      8.8.8.8 → 172.20.132.30 DNS 105 Standard query response 0x7ff5 A snowflake.com A 141.193.213.21 A 141.193.213.20
		Data:       []byte{0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x8, 0x0, 0x45, 0x0, 0x0, 0x5b, 0x9d, 0x93, 0x0, 0x0, 0x7b, 0x11, 0x61, 0xbc, 0x8, 0x8, 0x8, 0x8, 0xac, 0x14, 0x84, 0x1e, 0x0, 0x35, 0xc5, 0xcc, 0x0, 0x47, 0xd4, 0x7a, 0x7f, 0xf5, 0x81, 0x80, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x9, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0xa, 0x0, 0x4, 0x8d, 0xc1, 0xd5, 0x15, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0xa, 0x0, 0x4, 0x8d, 0xc1, 0xd5, 0x14},
		FullLength: 105,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 491180000},
	}, {
		// 5 1706286340.517634000 172.20.132.30 → 142.250.203.206 TCP 78 56125 → 80 [SYN] Seq=0 Win=65535 Len=0 MSS=1460 WS=64 TSval=2129770665 TSecr=0 SACK_PERM
		Data:       []byte{0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x8, 0x0, 0x45, 0x0, 0x0, 0x40, 0x0, 0x0, 0x40, 0x0, 0x40, 0x6, 0xaf, 0xbc, 0xac, 0x14, 0x84, 0x1e, 0x8e, 0xfa, 0xcb, 0xce, 0xdb, 0x3d, 0x0, 0x50, 0x4e, 0x31, 0xc2, 0x18, 0x0, 0x0, 0x0, 0x0, 0xb0, 0x2, 0xff, 0xff, 0x88, 0x8d, 0x0, 0x0, 0x2, 0x4, 0x5, 0xb4, 0x1, 0x3, 0x3, 0x6, 0x1, 0x1, 0x8, 0xa, 0x7e, 0xf1, 0xb8, 0xa9, 0x0, 0x0, 0x0, 0x0, 0x4, 0x2, 0x0, 0x0},
		FullLength: 78,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 517634000},
	}, {
		// 6 1706286340.542882000 142.250.203.206 → 172.20.132.30 TCP 74 80 → 56125 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1412 SACK_PERM TSval=3950401245 TSecr=2129770665 WS=256
		Data:       []byte{0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x8, 0x0, 0x45, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x40, 0x0, 0x7b, 0x6, 0x74, 0xc0, 0x8e, 0xfa, 0xcb, 0xce, 0xac, 0x14, 0x84, 0x1e, 0x0, 0x50, 0xdb, 0x3d, 0xb0, 0xb8, 0xbc, 0x61, 0x4e, 0x31, 0xc2, 0x19, 0xa0, 0x12, 0xff, 0xff, 0xea, 0x40, 0x0, 0x0, 0x2, 0x4, 0x5, 0x84, 0x4, 0x2, 0x8, 0xa, 0xeb, 0x76, 0x56, 0xdd, 0x7e, 0xf1, 0xb8, 0xa9, 0x1, 0x3, 0x3, 0x8},
		FullLength: 74,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 542882000},
	}, {
		// 7 1706286340.543128000 172.20.132.30 → 142.250.203.206 TCP 66 56125 → 80 [ACK] Seq=1 Ack=1 Win=131584 Len=0 TSval=2129770691 TSecr=3950401245
		Data:       []byte{0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x8, 0x0, 0x45, 0x0, 0x0, 0x34, 0x0, 0x0, 0x40, 0x0, 0x40, 0x6, 0xaf, 0xc8, 0xac, 0x14, 0x84, 0x1e, 0x8e, 0xfa, 0xcb, 0xce, 0xdb, 0x3d, 0x0, 0x50, 0x4e, 0x31, 0xc2, 0x19, 0xb0, 0xb8, 0xbc, 0x62, 0x80, 0x10, 0x8, 0x8, 0x10, 0xbc, 0x0, 0x0, 0x1, 0x1, 0x8, 0xa, 0x7e, 0xf1, 0xb8, 0xc3, 0xeb, 0x76, 0x56, 0xdd},
		FullLength: 66,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 543128000},
	}, {
		// 8 1706286340.543216000 172.20.132.30 → 142.250.203.206 HTTP 139 GET / HTTP/1.1
		Data:       []byte{0x0, 0x1b, 0x17, 0x0, 0x1, 0x11, 0x5c, 0xe9, 0x1e, 0x7e, 0x9d, 0xa8, 0x8, 0x0, 0x45, 0x0, 0x0, 0x7d, 0x0, 0x0, 0x40, 0x0, 0x40, 0x6, 0xaf, 0x7f, 0xac, 0x14, 0x84, 0x1e, 0x8e, 0xfa, 0xcb, 0xce, 0xdb, 0x3d, 0x0, 0x50, 0x4e, 0x31, 0xc2, 0x19, 0xb0, 0xb8, 0xbc, 0x62, 0x80, 0x18, 0x8, 0x8, 0x3c, 0x69, 0x0, 0x0, 0x1, 0x1, 0x8, 0xa, 0x7e, 0xf1, 0xb8, 0xc3, 0xeb, 0x76, 0x56, 0xdd, 0x47, 0x45, 0x54, 0x20, 0x2f, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0xd, 0xa, 0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0xd, 0xa, 0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x63, 0x75, 0x72, 0x6c, 0x2f, 0x38, 0x2e, 0x34, 0x2e, 0x30, 0xd, 0xa, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x3a, 0x20, 0x2a, 0x2f, 0x2a, 0xd, 0xa, 0xd, 0xa},
		FullLength: 139,
		Timestamp:  &timestamppb.Timestamp{Seconds: 1706286340, Nanos: 543216000},
	},
}
